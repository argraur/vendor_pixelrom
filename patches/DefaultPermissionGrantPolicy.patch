2a3
>  * Copyright (C) 2015 Alex Naidis <alex.naidis@linux.com> , Team Exodus, The Linux Foundation
20d20
< import android.annotation.NonNull;
24d23
< import android.content.pm.ActivityInfo;
34,36d32
< import android.os.Environment;
< import android.os.Handler;
< import android.os.Message;
38,39d33
< import android.os.storage.StorageManager;
< import android.print.PrintManager;
44d37
< import android.telephony.TelephonyManager;
46d38
< import android.util.ArrayMap;
49,53d40
< import android.util.Slog;
< import android.util.Xml;
< import com.android.internal.util.XmlUtils;
< import org.xmlpull.v1.XmlPullParser;
< import org.xmlpull.v1.XmlPullParserException;
55d41
< import java.io.BufferedInputStream;
57,59d42
< import java.io.FileInputStream;
< import java.io.IOException;
< import java.io.InputStream;
62d44
< import java.util.Map;
78,80d59
<     private static final int DEFAULT_FLAGS = PackageManager.MATCH_DIRECT_BOOT_AWARE
<             | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
< 
83,89d61
<     private static final String TAG_EXCEPTIONS = "exceptions";
<     private static final String TAG_EXCEPTION = "exception";
<     private static final String TAG_PERMISSION = "permission";
<     private static final String ATTR_PACKAGE = "package";
<     private static final String ATTR_NAME = "name";
<     private static final String ATTR_FIXED = "fixed";
< 
151,152d122
<     private static final int MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS = 1;
< 
154d123
<     private final Handler mHandler;
155a125
>     private PackagesProvider mImePackagesProvider;
163,164d132
<     private ArrayMap<String, List<DefaultPermissionGrant>> mGrantExceptions;
< 
167,178c135,138
<         mHandler = new Handler(mService.mHandlerThread.getLooper()) {
<             @Override
<             public void handleMessage(Message msg) {
<                 if (msg.what == MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS) {
<                     synchronized (mService.mPackages) {
<                         if (mGrantExceptions == null) {
<                             mGrantExceptions = readDefaultPermissionExceptionsLPw();
<                         }
<                     }
<                 }
<             }
<         };
---
>     }
> 
>     public void setImePackagesProviderLPr(PackagesProvider provider) {
>         mImePackagesProvider = provider;
208,212d167
<         grantDefaultPermissionExceptions(userId);
<     }
< 
<     public void scheduleReadDefaultPermissionExceptions() {
<         mHandler.sendEmptyMessage(MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS);
243a199
>         final PackagesProvider imePackagesProvider;
251a208
>             imePackagesProvider = mImePackagesProvider;
259a217,218
>         String[] imePackageNames = (imePackagesProvider != null)
>                 ? imePackagesProvider.getPackages(userId) : null;
295,296c254,257
<             PackageParser.Package setupPackage = getSystemPackageLPr(
<                     mService.mSetupWizardPackage);
---
>             Intent setupIntent = new Intent(Intent.ACTION_MAIN);
>             setupIntent.addCategory(Intent.CATEGORY_SETUP_WIZARD);
>             PackageParser.Package setupPackage = getDefaultSystemHandlerActivityPackageLPr(
>                     setupIntent, userId);
301,302d261
<                 grantRuntimePermissionsLPw(setupPackage, LOCATION_PERMISSIONS, userId);
<                 grantRuntimePermissionsLPw(setupPackage, CAMERA_PERMISSIONS, userId);
521d479
<                 grantRuntimePermissionsLPw(emailPackage, CALENDAR_PERMISSIONS, userId);
540a499,509
>             // IME
>             if (imePackageNames != null) {
>                 for (String imePackageName : imePackageNames) {
>                     PackageParser.Package imePackage = getSystemPackageLPr(imePackageName);
>                     if (imePackage != null
>                             && doesPackageSupportRuntimePermissions(imePackage)) {
>                         grantRuntimePermissionsLPw(imePackage, CONTACTS_PERMISSIONS, userId);
>                     }
>                 }
>             }
> 
606,662c575,660
<             // Android Wear Home
<             if (mService.hasSystemFeature(PackageManager.FEATURE_WATCH, 0)) {
<                 Intent homeIntent = new Intent(Intent.ACTION_MAIN);
<                 homeIntent.addCategory(Intent.CATEGORY_HOME_MAIN);
< 
<                 PackageParser.Package wearHomePackage = getDefaultSystemHandlerActivityPackageLPr(
<                         homeIntent, userId);
< 
<                 if (wearHomePackage != null
<                         && doesPackageSupportRuntimePermissions(wearHomePackage)) {
<                     grantRuntimePermissionsLPw(wearHomePackage, CONTACTS_PERMISSIONS, false,
<                             userId);
<                     grantRuntimePermissionsLPw(wearHomePackage, PHONE_PERMISSIONS, true, userId);
<                     grantRuntimePermissionsLPw(wearHomePackage, MICROPHONE_PERMISSIONS, false,
<                             userId);
<                     grantRuntimePermissionsLPw(wearHomePackage, LOCATION_PERMISSIONS, false,
<                             userId);
<                 }
<             }
< 
<             // Print Spooler
<             PackageParser.Package printSpoolerPackage = getSystemPackageLPr(
<                     PrintManager.PRINT_SPOOLER_PACKAGE_NAME);
<             if (printSpoolerPackage != null
<                     && doesPackageSupportRuntimePermissions(printSpoolerPackage)) {
<                 grantRuntimePermissionsLPw(printSpoolerPackage, LOCATION_PERMISSIONS, true, userId);
<             }
< 
<             // EmergencyInfo
<             Intent emergencyInfoIntent = new Intent(TelephonyManager.ACTION_EMERGENCY_ASSISTANCE);
<             PackageParser.Package emergencyInfoPckg = getDefaultSystemHandlerActivityPackageLPr(
<                     emergencyInfoIntent, userId);
<             if (emergencyInfoPckg != null
<                     && doesPackageSupportRuntimePermissions(emergencyInfoPckg)) {
<                 grantRuntimePermissionsLPw(emergencyInfoPckg, CONTACTS_PERMISSIONS, true, userId);
<                 grantRuntimePermissionsLPw(emergencyInfoPckg, PHONE_PERMISSIONS, true, userId);
<             }
< 
<             // NFC Tag viewer
<             Intent nfcTagIntent = new Intent(Intent.ACTION_VIEW);
<             nfcTagIntent.setType("vnd.android.cursor.item/ndef_msg");
<             PackageParser.Package nfcTagPkg = getDefaultSystemHandlerActivityPackageLPr(
<                     nfcTagIntent, userId);
<             if (nfcTagPkg != null
<                     && doesPackageSupportRuntimePermissions(nfcTagPkg)) {
<                 grantRuntimePermissionsLPw(nfcTagPkg, CONTACTS_PERMISSIONS, false, userId);
<                 grantRuntimePermissionsLPw(nfcTagPkg, PHONE_PERMISSIONS, false, userId);
<             }
< 
<             // Storage Manager
<             Intent storageManagerIntent = new Intent(StorageManager.ACTION_MANAGE_STORAGE);
<             PackageParser.Package storageManagerPckg = getDefaultSystemHandlerActivityPackageLPr(
<                     storageManagerIntent, userId);
<             if (storageManagerPckg != null
<                     && doesPackageSupportRuntimePermissions(storageManagerPckg)) {
<                 grantRuntimePermissionsLPw(storageManagerPckg, STORAGE_PERMISSIONS, true, userId);
<             }
---
>             // Google Account
>             PackageParser.Package googleaccountPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.gsf.login", userId);
>             if (googleaccountPackage != null) {
>                 grantRuntimePermissionsLPw(googleaccountPackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleaccountPackage, PHONE_PERMISSIONS, userId);
>             }
> 
>             // Google App
>             PackageParser.Package googleappPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.googlequicksearchbox", userId);
>             if (googleappPackage != null) {
>                 grantRuntimePermissionsLPw(googleappPackage, CALENDAR_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, CAMERA_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, LOCATION_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, MICROPHONE_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, PHONE_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, SMS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(googleappPackage, STORAGE_PERMISSIONS, userId);
>             }
> 
>             // Google Play Services
>             PackageParser.Package gmscorePackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.gms", userId);
>             if (gmscorePackage != null) {
>                 grantRuntimePermissionsLPw(gmscorePackage, SENSORS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, CALENDAR_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, CAMERA_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, LOCATION_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, MICROPHONE_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, PHONE_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, SMS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gmscorePackage, STORAGE_PERMISSIONS, userId);
>             }
> 
> 			// Google Connectivity Services
>             PackageParser.Package gcsPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.apps.gcs", userId);
>             if (gcsPackage != null) {
>                 grantRuntimePermissionsLPw(gcsPackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gcsPackage, LOCATION_PERMISSIONS, userId);
>             }
> 
> 			// Google Contacts Sync
>             PackageParser.Package googlecontactssyncPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.syncadapters.contacts", userId);
>             if (googlecontactssyncPackage != null) {
>                 grantRuntimePermissionsLPw(googlecontactssyncPackage, CONTACTS_PERMISSIONS, userId);
>             }			
> 
> 			// Google Backup Transport
>             PackageParser.Package googlebackuptransportPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.backuptransport", userId);
>             if (googlebackuptransportPackage != null) {
>                 grantRuntimePermissionsLPw(googlebackuptransportPackage, CONTACTS_PERMISSIONS, userId);
>             }			
> 			
> 			// Google Play Framework
>             PackageParser.Package gsfcorePackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.gsf", userId);
>             if (gsfcorePackage != null) {
>                 grantRuntimePermissionsLPw(gsfcorePackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(gsfcorePackage, PHONE_PERMISSIONS, userId);
>             }		
> 
> 			// Google Setup Wizard
>             PackageParser.Package setupwizardPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.google.android.setupwizard", userId);
>             if (setupwizardPackage != null) {
>                 grantRuntimePermissionsLPw(setupwizardPackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(setupwizardPackage, PHONE_PERMISSIONS, userId);
>             }	
> 
> 			// Google Play Store
>             PackageParser.Package vendingPackage = getDefaultProviderAuthorityPackageLPr(
>                     "com.android.vending", userId);
>             if (vendingPackage != null) {
>                 grantRuntimePermissionsLPw(vendingPackage, CONTACTS_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(vendingPackage, PHONE_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(vendingPackage, LOCATION_PERMISSIONS, userId);
>                 grantRuntimePermissionsLPw(vendingPackage, SMS_PERMISSIONS, userId);
>             }	
> 				
> 			
670,673c668
<             boolean isPhonePermFixed =
<                     mService.hasSystemFeature(PackageManager.FEATURE_WATCH, 0);
<             grantRuntimePermissionsLPw(
<                     dialerPackage, PHONE_PERMISSIONS, isPhonePermFixed, userId);
---
>             grantRuntimePermissionsLPw(dialerPackage, PHONE_PERMISSIONS, userId);
677d671
<             grantRuntimePermissionsLPw(dialerPackage, CAMERA_PERMISSIONS, userId);
680a675
> 
685a681
>             grantRuntimePermissionsLPw(smsPackage, PHONE_PERMISSIONS, userId);
686a683
>             grantRuntimePermissionsLPw(smsPackage, STORAGE_PERMISSIONS, true, userId);
689a687
> 
715d712
<             grantRuntimePermissionsLPw(dialerPackage, CAMERA_PERMISSIONS, false, true, userId);
768,770c765,768
<         ResolveInfo handler = mService.resolveIntent(intent,
<                 intent.resolveType(mService.mContext.getContentResolver()), DEFAULT_FLAGS, userId);
<         if (handler == null || handler.activityInfo == null) {
---
>         List<ResolveInfo> handlers = mService.mActivities.queryIntent(intent,
>                 intent.resolveType(mService.mContext.getContentResolver()),
>                 PackageManager.GET_DISABLED_COMPONENTS, userId);
>         if (handlers == null) {
773,776c771,778
<         ActivityInfo activityInfo = handler.activityInfo;
<         if (activityInfo.packageName.equals(mService.mResolveActivity.packageName)
<                 && activityInfo.name.equals(mService.mResolveActivity.name)) {
<             return null;
---
>         final int handlerCount = handlers.size();
>         for (int i = 0; i < handlerCount; i++) {
>             ResolveInfo handler = handlers.get(i);
>             PackageParser.Package handlerPackage = getSystemPackageLPr(
>                     handler.activityInfo.packageName);
>             if (handlerPackage != null) {
>                 return handlerPackage;
>             }
778c780
<         return getSystemPackageLPr(handler.activityInfo.packageName);
---
>         return null;
784,785c786,787
<                 intent.resolveType(mService.mContext.getContentResolver()), DEFAULT_FLAGS, userId)
<                 .getList();
---
>                 intent.resolveType(mService.mContext.getContentResolver()),
>                 PackageManager.GET_DISABLED_COMPONENTS, userId);
811,814c813,816
<             ResolveInfo homeActivity = mService.resolveIntent(homeIntent,
<                     homeIntent.resolveType(mService.mContext.getContentResolver()), DEFAULT_FLAGS,
<                     userId);
<             if (homeActivity != null) {
---
>             List<ResolveInfo> homeActivities = mService.mActivities.queryIntent(homeIntent,
>                     homeIntent.resolveType(mService.mContext.getContentResolver()),
>                     PackageManager.GET_DISABLED_COMPONENTS, userId);
>             if (!homeActivities.isEmpty()) {
829c831
<         ProviderInfo provider = mService.resolveContentProvider(authority, DEFAULT_FLAGS, userId);
---
>         ProviderInfo provider = mService.resolveContentProvider(authority, 0, userId);
859c861
<             boolean systemFixed, boolean isDefaultPhoneOrSms, int userId) {
---
>             boolean systemFixed, boolean overrideUserChoice,  int userId) {
867,873c869
<         // If this is the default Phone or SMS app we grant permissions regardless
<         // whether the version on the system image declares the permission as used since
<         // selecting the app as the default Phone or SMS the user makes a deliberate
<         // choice to grant this app the permissions needed to function. For all other
<         // apps, (default grants on first boot and user creation) we don't grant default
<         // permissions if the version on the system image does not declare them.
<         if (!isDefaultPhoneOrSms && pkg.isUpdatedSystemApp()) {
---
>         if (pkg.isUpdatedSystemApp()) {
905c901
<                 if (flags == 0 || isDefaultPhoneOrSms) {
---
>                 if (flags == 0 || overrideUserChoice) {
915,916c911,912
<                         Log.i(TAG, "Granted " + (systemFixed ? "fixed " : "not fixed ")
<                                 + permission + " to default handler " + pkg.packageName);
---
>                         Log.i(TAG, "Granted " + permission + " to default handler "
>                                 + pkg.packageName);
927,939d922
< 
<                 // If a component gets a permission for being the default handler A
<                 // and also default handler B, we grant the weaker grant form.
<                 if ((flags & PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0
<                         && (flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0
<                         && !systemFixed) {
<                     if (DEBUG) {
<                         Log.i(TAG, "Granted not fixed " + permission + " to default handler "
<                                 + pkg.packageName);
<                     }
<                     mService.updatePermissionFlags(permission, pkg.packageName,
<                             PackageManager.FLAG_PERMISSION_SYSTEM_FIXED, 0, userId);
<                 }
952c935
<         if (sysPkg != null && sysPkg.pkg != null) {
---
>         if (sysPkg != null) {
963,1120d945
<     private void grantDefaultPermissionExceptions(int userId) {
<         synchronized (mService.mPackages) {
<             mHandler.removeMessages(MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS);
< 
<             if (mGrantExceptions == null) {
<                 mGrantExceptions = readDefaultPermissionExceptionsLPw();
<             }
< 
<             // mGrantExceptions is null only before the first read and then
<             // it serves as a cache of the default grants that should be
<             // performed for every user. If there is an entry then the app
<             // is on the system image and supports runtime permissions.
<             Set<String> permissions = null;
<             final int exceptionCount = mGrantExceptions.size();
<             for (int i = 0; i < exceptionCount; i++) {
<                 String packageName = mGrantExceptions.keyAt(i);
<                 PackageParser.Package pkg = getSystemPackageLPr(packageName);
<                 List<DefaultPermissionGrant> permissionGrants = mGrantExceptions.valueAt(i);
<                 final int permissionGrantCount = permissionGrants.size();
<                 for (int j = 0; j < permissionGrantCount; j++) {
<                     DefaultPermissionGrant permissionGrant = permissionGrants.get(j);
<                     if (permissions == null) {
<                         permissions = new ArraySet<>();
<                     } else {
<                         permissions.clear();
<                     }
<                     permissions.add(permissionGrant.name);
<                     grantRuntimePermissionsLPw(pkg, permissions, false,
<                             permissionGrant.fixed, userId);
<                 }
<             }
<         }
<     }
< 
<     private @NonNull ArrayMap<String, List<DefaultPermissionGrant>>
<             readDefaultPermissionExceptionsLPw() {
<         File dir = new File(Environment.getRootDirectory(), "etc/default-permissions");
<         if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
<             return new ArrayMap<>(0);
<         }
< 
<         File[] files = dir.listFiles();
<         if (files == null) {
<             return new ArrayMap<>(0);
<         }
< 
<         ArrayMap<String, List<DefaultPermissionGrant>> grantExceptions = new ArrayMap<>();
< 
<         // Iterate over the files in the directory and scan .xml files
<         for (File file : files) {
<             if (!file.getPath().endsWith(".xml")) {
<                 Slog.i(TAG, "Non-xml file " + file + " in " + dir + " directory, ignoring");
<                 continue;
<             }
<             if (!file.canRead()) {
<                 Slog.w(TAG, "Default permissions file " + file + " cannot be read");
<                 continue;
<             }
<             try (
<                 InputStream str = new BufferedInputStream(new FileInputStream(file))
<             ) {
<                 XmlPullParser parser = Xml.newPullParser();
<                 parser.setInput(str, null);
<                 parse(parser, grantExceptions);
<             } catch (XmlPullParserException | IOException e) {
<                 Slog.w(TAG, "Error reading default permissions file " + file, e);
<             }
<         }
< 
<         return grantExceptions;
<     }
< 
<     private void parse(XmlPullParser parser, Map<String, List<DefaultPermissionGrant>>
<             outGrantExceptions) throws IOException, XmlPullParserException {
<         final int outerDepth = parser.getDepth();
<         int type;
<         while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
<                 && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
<             if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
<                 continue;
<             }
<             if (TAG_EXCEPTIONS.equals(parser.getName())) {
<                 parseExceptions(parser, outGrantExceptions);
<             } else {
<                 Log.e(TAG, "Unknown tag " + parser.getName());
<             }
<         }
<     }
< 
<     private void parseExceptions(XmlPullParser parser, Map<String, List<DefaultPermissionGrant>>
<             outGrantExceptions) throws IOException, XmlPullParserException {
<         final int outerDepth = parser.getDepth();
<         int type;
<         while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
<                 && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
<             if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
<                 continue;
<             }
<             if (TAG_EXCEPTION.equals(parser.getName())) {
<                 String packageName = parser.getAttributeValue(null, ATTR_PACKAGE);
< 
<                 List<DefaultPermissionGrant> packageExceptions =
<                         outGrantExceptions.get(packageName);
<                 if (packageExceptions == null) {
<                     // The package must be on the system image
<                     PackageParser.Package pkg = getSystemPackageLPr(packageName);
<                     if (pkg == null) {
<                         Log.w(TAG, "Unknown package:" + packageName);
<                         XmlUtils.skipCurrentTag(parser);
<                         continue;
<                     }
< 
<                     // The package must support runtime permissions
<                     if (!doesPackageSupportRuntimePermissions(pkg)) {
<                         Log.w(TAG, "Skipping non supporting runtime permissions package:"
<                                 + packageName);
<                         XmlUtils.skipCurrentTag(parser);
<                         continue;
<                     }
<                     packageExceptions = new ArrayList<>();
<                     outGrantExceptions.put(packageName, packageExceptions);
<                 }
< 
<                 parsePermission(parser, packageExceptions);
<             } else {
<                 Log.e(TAG, "Unknown tag " + parser.getName() + "under <exceptions>");
<             }
<         }
<     }
< 
<     private void parsePermission(XmlPullParser parser, List<DefaultPermissionGrant>
<             outPackageExceptions) throws IOException, XmlPullParserException {
<         final int outerDepth = parser.getDepth();
<         int type;
<         while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
<                 && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
<             if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
<                 continue;
<             }
< 
<             if (TAG_PERMISSION.contains(parser.getName())) {
<                 String name = parser.getAttributeValue(null, ATTR_NAME);
<                 if (name == null) {
<                     Log.w(TAG, "Mandatory name attribute missing for permission tag");
<                     XmlUtils.skipCurrentTag(parser);
<                     continue;
<                 }
< 
<                 final boolean fixed = XmlUtils.readBooleanAttribute(parser, ATTR_FIXED);
< 
<                 DefaultPermissionGrant exception = new DefaultPermissionGrant(name, fixed);
<                 outPackageExceptions.add(exception);
<             } else {
<                 Log.e(TAG, "Unknown tag " + parser.getName() + "under <exception>");
<             }
<         }
<     }
< 
1123,1132d947
<     }
< 
<     private static final class DefaultPermissionGrant {
<         final String name;
<         final boolean fixed;
< 
<         public DefaultPermissionGrant(String name, boolean fixed) {
<             this.name = name;
<             this.fixed = fixed;
<         }
